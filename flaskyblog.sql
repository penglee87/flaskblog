-- MySQL dump 10.13  Distrib 5.7.9, for Win64 (x86_64)
--
-- Host: 121.43.61.62    Database: flasky
-- ------------------------------------------------------
-- Server version	5.5.49-0ubuntu0.14.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `alembic_version`
--

DROP TABLE IF EXISTS `alembic_version`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `alembic_version` (
  `version_num` varchar(32) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `alembic_version`
--

LOCK TABLES `alembic_version` WRITE;
/*!40000 ALTER TABLE `alembic_version` DISABLE KEYS */;
INSERT INTO `alembic_version` VALUES ('51f5ccfba190');
/*!40000 ALTER TABLE `alembic_version` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comments`
--

DROP TABLE IF EXISTS `comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comments` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `body` text,
  `body_html` text,
  `timestamp` datetime DEFAULT NULL,
  `disabled` tinyint(1) DEFAULT NULL,
  `author_id` int(11) DEFAULT NULL,
  `post_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `author_id` (`author_id`),
  KEY `post_id` (`post_id`),
  KEY `ix_comments_timestamp` (`timestamp`),
  CONSTRAINT `comments_ibfk_1` FOREIGN KEY (`author_id`) REFERENCES `users` (`id`),
  CONSTRAINT `comments_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comments`
--

LOCK TABLES `comments` WRITE;
/*!40000 ALTER TABLE `comments` DISABLE KEYS */;
/*!40000 ALTER TABLE `comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `follows`
--

DROP TABLE IF EXISTS `follows`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `follows` (
  `follower_id` int(11) NOT NULL,
  `followed_id` int(11) NOT NULL,
  `timestamp` datetime DEFAULT NULL,
  PRIMARY KEY (`follower_id`,`followed_id`),
  KEY `followed_id` (`followed_id`),
  CONSTRAINT `follows_ibfk_1` FOREIGN KEY (`followed_id`) REFERENCES `users` (`id`),
  CONSTRAINT `follows_ibfk_2` FOREIGN KEY (`follower_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `follows`
--

LOCK TABLES `follows` WRITE;
/*!40000 ALTER TABLE `follows` DISABLE KEYS */;
INSERT INTO `follows` VALUES (1,1,'2016-06-09 09:57:05'),(2,1,'2016-07-08 09:16:01'),(2,2,'2016-07-01 02:44:04'),(3,3,'2016-07-08 09:05:09'),(4,4,'2016-08-10 09:55:00');
/*!40000 ALTER TABLE `follows` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `posts`
--

DROP TABLE IF EXISTS `posts`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `posts` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `body` text,
  `timestamp` datetime DEFAULT NULL,
  `author_id` int(11) DEFAULT NULL,
  `body_html` text,
  `title` varchar(64) DEFAULT NULL,
  `summary` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `author_id` (`author_id`),
  KEY `ix_posts_timestamp` (`timestamp`),
  CONSTRAINT `posts_ibfk_1` FOREIGN KEY (`author_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `posts`
--

LOCK TABLES `posts` WRITE;
/*!40000 ALTER TABLE `posts` DISABLE KEYS */;
INSERT INTO `posts` VALUES (1,'本站基于 Flask Web Development（中文版） 这本书完成，略有更改  \r\n原书网址： http://www.flaskbook.com  \r\n原书代码： https://github.com/miguelgrinberg/flasky  \r\n原作者网站： http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iii-web-forms  \r\n配置中解决mysql中文乱码，增加博客文章的 cacel 、delete 等功能  \r\n使用flask-pagedown 支持 markdown 及时编辑  \r\n\r\n    python manage.py db init\r\n    python manage.py db migrate -m \"initial migration\"\r\n    python manage.py db upgrade\r\n    python manage.py shell  (db.drop_all(),db.create_all())\r\n    Role.insert_roles()\r\n    插入用户\r\n    u=User(username=\'lipeng\',email=\'lipeng@qccr.com\',password=\'lipeng\')\r\n    db.session.add(u)\r\n    db.session.commit()\r\n\r\n','2016-06-09 09:57:45',1,'<p>本站基于 Flask Web Development（中文版） 这本书完成，略有更改<br>\n原书网址： <a href=\"http://www.flaskbook.com\" rel=\"nofollow\">http://www.flaskbook.com</a><br>\n原书代码： <a href=\"https://github.com/miguelgrinberg/flasky\" rel=\"nofollow\">https://github.com/miguelgrinberg/flasky</a><br>\n原作者网站： <a href=\"http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iii-web-forms\" rel=\"nofollow\">http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iii-web-forms</a><br>\n配置中解决mysql中文乱码，增加博客文章的 cacel 、delete 等功能<br>\n使用flask-pagedown 支持 markdown 及时编辑  </p>\n<pre><code>python <a href=\"http://manage.py\" rel=\"nofollow\">manage.py</a> db init\npython <a href=\"http://manage.py\" rel=\"nofollow\">manage.py</a> db migrate -m \"initial migration\"\npython <a href=\"http://manage.py\" rel=\"nofollow\">manage.py</a> db upgrade\npython <a href=\"http://manage.py\" rel=\"nofollow\">manage.py</a> shell  (db.drop_all(),db.create_all())\nRole.insert_roles()\n插入用户\nu=User(username=\'lipeng\',email=\'lipeng@qccr.com\',password=\'lipeng\')\ndb.session.add(u)\ndb.session.commit()\n</code></pre>','关于本站','基于 Flask Web Development'),(2,'##Linux系统ssh和scp命令\r\n\r\n如果ssh的端口是22，那么可以不用指定-p或-P选项。\r\n\r\n###1. ssh  \r\nLinux使用ssh命令登陆Linux服务器：  \r\n\r\nssh -l root -p 188 192.168.1.2  \r\n\r\nssh -l 用户名 -p 端口号 主机名或IP  \r\n\r\n输入密码即可\r\n\r\n\r\n###2. scp  \r\nscp命令复制文件或目录命令： \r\n\r\n复制文件：  \r\n\r\n（1）将本地文件拷贝到远程  \r\n\r\nscp -P 22 文件名 用户名@计算机IP或者计算机名称:远程路径  \r\n \r\nscp -P 22 test.txt root@192.168.1.163:/opt/   \r\n\r\n（2）从远程将文件拷回本地  \r\n\r\nscp -P 22 用户名@计算机IP或者计算机名称:文件名 本地路径  \r\n\r\nscp -P 22 root@192.168.1.163:/opt/test.txt /opt  \r\n\r\n复制目录：  \r\n\r\n（1）将本地目录拷贝到远程  \r\n\r\nscp -r -P 22 目录名 用户名@计算机IP或者计算机名称:远程路径   \r\n\r\nscp -r -P 22 /opt/test/ root@192.168.1.163:/opt/    \r\n\r\n（2）从远程将目录拷回本地   \r\n\r\nscp -r -P 22 用户名@计算机IP或者计算机名称:目录名 本地路径   \r\n\r\nscp -r -P 22 root@192.168.1.163:/opt/test/ /opt/   \r\n\r\n###3. 使用问题\r\n\r\n若本机可以使用scp，那么执行scp上传文件时，报错误：\r\n\r\nbash: scp: command not found\r\n\r\nlost connection\r\n\r\n那么说明对方没有安装openssh-clients软件包。\r\n\r\n\r\n### sftp 命令\r\nsecurecrt 按下ALT+P就开启新的会话 进行ftp操作。  \r\n输入:help命令，显示该FTP提供所有的命令  \r\npwd: 查询linux主机所在目录(也就是远程主机目录)  \r\nlpwd: 查询本地目录（本地目录）\r\nls: 查询连接到当前linux主机所在目录有哪些文件  \r\nlls: 查询当前本地上传目录有哪些文件  \r\nlcd: 改变本地上传目录的路径  \r\ncd: 改变远程上传目录  \r\nget: 将远程目录中文件下载到本地目录  \r\nput: 将本地目录中文件上传到远程主机  \r\nget -r : 下载目录  \r\nput -r : 上传目录','2016-06-16 03:55:41',1,'<h2>Linux系统ssh和scp命令</h2>\n<p>如果ssh的端口是22，那么可以不用指定-p或-P选项。</p>\n<h3>1. ssh</h3>\n<p>Linux使用ssh命令登陆Linux服务器：  </p>\n<p>ssh -l root -p 188 192.168.1.2  </p>\n<p>ssh -l 用户名 -p 端口号 主机名或IP  </p>\n<p>输入密码即可</p>\n<h3>2. scp</h3>\n<p>scp命令复制文件或目录命令： </p>\n<p>复制文件：  </p>\n<p>（1）将本地文件拷贝到远程  </p>\n<p>scp -P 22 文件名 用户名@计算机IP或者计算机名称:远程路径  </p>\n<p>scp -P 22 test.txt root@192.168.1.163:/opt/   </p>\n<p>（2）从远程将文件拷回本地  </p>\n<p>scp -P 22 用户名@计算机IP或者计算机名称:文件名 本地路径  </p>\n<p>scp -P 22 root@192.168.1.163:/opt/test.txt /opt  </p>\n<p>复制目录：  </p>\n<p>（1）将本地目录拷贝到远程  </p>\n<p>scp -r -P 22 目录名 用户名@计算机IP或者计算机名称:远程路径   </p>\n<p>scp -r -P 22 /opt/test/ root@192.168.1.163:/opt/    </p>\n<p>（2）从远程将目录拷回本地   </p>\n<p>scp -r -P 22 用户名@计算机IP或者计算机名称:目录名 本地路径   </p>\n<p>scp -r -P 22 root@192.168.1.163:/opt/test/ /opt/   </p>\n<h3>3. 使用问题</h3>\n<p>若本机可以使用scp，那么执行scp上传文件时，报错误：</p>\n<p>bash: scp: command not found</p>\n<p>lost connection</p>\n<p>那么说明对方没有安装openssh-clients软件包。</p>\n<h3>sftp 命令</h3>\n<p>securecrt 按下ALT+P就开启新的会话 进行ftp操作。<br>\n输入:help命令，显示该FTP提供所有的命令<br>\npwd: 查询linux主机所在目录(也就是远程主机目录)<br>\nlpwd: 查询本地目录（本地目录）\nls: 查询连接到当前linux主机所在目录有哪些文件<br>\nlls: 查询当前本地上传目录有哪些文件<br>\nlcd: 改变本地上传目录的路径<br>\ncd: 改变远程上传目录<br>\nget: 将远程目录中文件下载到本地目录<br>\nput: 将本地目录中文件上传到远程主机<br>\nget -r : 下载目录<br>\nput -r : 上传目录</p>','Linux系统ssh和scp命令\r\n\r\n','Linux系统ssh和scp命令\r\n\r\n'),(4,'##flask import问题\r\nflask中很多第三方扩展包，有两种导入方式，如下：\r\n\r\nimport flask.ext.pagedown  \r\nimport flask_pagedown','2016-06-16 06:21:25',1,'<h2>flask import问题</h2>\n<p>flask中很多第三方扩展包，有两种导入方式，如下：</p>\n<p>import flask.ext.pagedown<br>\nimport flask_pagedown</p>','flask import问题','flask中第三方扩展包的两种导入方式'),(5,'配置类可以定义 init_app() 类方法，其参数是程序实例。在这个方法中，可以执行对当前环境的配置初始化。\r\n\r\n构造文件(__init__.py)导入了大多数正在使用的 Flask 扩展。由于尚未初始化所需的程序实例，所以没\r\n有初始化扩展，创建扩展类时没有向构造函数传入参数。 create_app() 函数就是程序的工\r\n厂函数，接受一个参数，是程序使用的配置名。配置类在 config.py 文件中定义，其中保存\r\n的配置可以使用 Flask  app.config 配置对象提供的 from_object() 方法直接导入程序。至\r\n于配置对象，则可以通过名字从 config 字典中选择。程序创建并配置好后，就能初始化\r\n扩展了。在之前创建的扩展对象上调用 init_app() 可以完成初始化过程。\r\n\r\n    class Config:  \r\n        SECRET_KEY = os.environ.get(\'SECRET_KEY\') or \'hard to guess string\'  \r\n        SQLALCHEMY_COMMIT_ON_TEARDOWN = True  \r\n        MAIL_SERVER = \'smtp.googlemail.com\'  \r\n        MAIL_PORT = 587  \r\n        MAIL_USE_TLS = True  \r\n        MAIL_USERNAME = os.environ.get(\'MAIL_USERNAME\')  \r\n        MAIL_PASSWORD = os.environ.get(\'MAIL_PASSWORD\')  \r\n        FLASKY_MAIL_SUBJECT_PREFIX = \'[Flasky]\'  \r\n        FLASKY_MAIL_SENDER = \'Flasky Admin <flasky@example.com>\'  \r\n        FLASKY_ADMIN = os.environ.get(\'FLASKY_ADMIN\')  \r\n        @staticmethod  \r\n        def init_app(app):  \r\n            pass\r\n\r\n','2016-06-16 10:08:03',1,'<p>配置类可以定义 init_app() 类方法，其参数是程序实例。在这个方法中，可以执行对当前环境的配置初始化。</p>\n<p>构造文件(<strong>init</strong>.py)导入了大多数正在使用的 Flask 扩展。由于尚未初始化所需的程序实例，所以没\n有初始化扩展，创建扩展类时没有向构造函数传入参数。 create_app() 函数就是程序的工\n厂函数，接受一个参数，是程序使用的配置名。配置类在 <a href=\"http://config.py\" rel=\"nofollow\">config.py</a> 文件中定义，其中保存\n的配置可以使用 Flask  app.config 配置对象提供的 from_object() 方法直接导入程序。至\n于配置对象，则可以通过名字从 config 字典中选择。程序创建并配置好后，就能初始化\n扩展了。在之前创建的扩展对象上调用 init_app() 可以完成初始化过程。</p>\n<pre><code>class Config:  \n    SECRET_KEY = os.environ.get(\'SECRET_KEY\') or \'hard to guess string\'  \n    SQLALCHEMY_COMMIT_ON_TEARDOWN = True  \n    MAIL_SERVER = \'<a href=\"http://smtp.googlemail.com\" rel=\"nofollow\">smtp.googlemail.com</a>\'  \n    MAIL_PORT = 587  \n    MAIL_USE_TLS = True  \n    MAIL_USERNAME = os.environ.get(\'MAIL_USERNAME\')  \n    MAIL_PASSWORD = os.environ.get(\'MAIL_PASSWORD\')  \n    FLASKY_MAIL_SUBJECT_PREFIX = \'[Flasky]\'  \n    FLASKY_MAIL_SENDER = \'Flasky Admin &lt;flasky@example.com&gt;\'  \n    FLASKY_ADMIN = os.environ.get(\'FLASKY_ADMIN\')  \n    @staticmethod  \n    def init_app(app):  \n        pass\n</code></pre>','flaskweb 工厂函数','类可以定义 init_app() 类方法'),(7,'###mysql 常用语句\r\ncreate user flasky identified by \'flasky\';  \r\ncreate database flasky;  \r\ngrant all privileges on flasky.* to flasky ;  \r\n\r\nuse flasky;  \r\nselect database();  \r\nselect user();  \r\n\r\nselect user,host from mysql.user;  \r\nshow databases;  \r\nshow tables;  \r\nshow table status from flasky where name=\'users\';  \r\n\r\n###导出导入  \r\n登陆前运行如下：  \r\nmysqldump -uflasky -p -h121.43.61.62 flasky >flaskycopy.sql  \r\nmysql -uflasky -p < flaskycopy.sql\r\n登陆后运行如下：  \r\nuse flasky;  \r\nsource flaskycopy.sql\r\n\r\nalter table posts add title varchar(64) ;  \r\nupdate posts set title=SUBSTR(body,3,locate(\'\\n\',body));  \r\ncommit;\r\n','2016-06-17 12:56:28',1,'<h3>mysql 常用语句</h3>\n<p>create user flasky identified by \'flasky\';<br>\ncreate database flasky;<br>\ngrant all privileges on flasky.* to flasky ;  </p>\n<p>use flasky;<br>\nselect database();<br>\nselect user();  </p>\n<p>select user,host from mysql.user;<br>\nshow databases;<br>\nshow tables;<br>\nshow table status from flasky where name=\'users\';  </p>\n<h3>导出导入</h3>\n<p>登陆前运行如下：<br>\nmysqldump -uflasky -p -h121.43.61.62 flasky &gt;flaskycopy.sql<br>\nmysql -uflasky -p &lt; flaskycopy.sql\n登陆后运行如下：<br>\nuse flasky;<br>\nsource flaskycopy.sql</p>\n<p>alter table posts add title varchar(64) ;<br>\nupdate posts set title=SUBSTR(body,3,locate(\'\\n\',body));<br>\ncommit;</p>','mysql 常用语句','mysql 常用语句'),(16,'转自 http://www.cnblogs.com/rollenholt/archive/2012/05/02/2479833.html\r\n\r\n文章先由stackoverflow上面的一个问题引起吧，如果使用如下的代码：\r\n\r\n    @makebold\r\n    @makeitalic\r\n    def say():\r\n       return \"Hello\"\r\n    打印出如下的输出：\r\n    <b><i>Hello<i></b>\r\n    你会怎么做？最后给出的答案是：\r\n    def makebold(fn):\r\n        def wrapped():\r\n            return \"<b>\" + fn() + \"</b>\"\r\n        return wrapped\r\n     \r\n    def makeitalic(fn):\r\n        def wrapped():\r\n            return \"<i>\" + fn() + \"</i>\"\r\n        return wrapped\r\n     \r\n    @makebold\r\n    @makeitalic\r\n    def hello():\r\n        return \"hello world\"\r\n     \r\n    print hello() ## 返回 <b><i>hello world</i></b>\r\n\r\n现在我们来看看如何从一些最基础的方式来理解Python的装饰器。英文讨论参考Here。\r\n装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。\r\n1.1. 需求是怎么来的？\r\n\r\n装饰器的定义很是抽象，我们来看一个小例子。\r\n \r\n    def foo():\r\n        print \'in foo()\'\r\n    foo()\r\n\r\n这是一个很无聊的函数没错。但是突然有一个更无聊的人，我们称呼他为B君，说我想看看执行这个函数用了多长时间，好吧，那么我们可以这样做：\r\n\r\n    import time\r\n    def foo():\r\n        start = time.clock()\r\n        print \'in foo()\'\r\n        end = time.clock()\r\n        print \'used:\', end - start\r\n     \r\n    foo()\r\n\r\n很好，功能看起来无懈可击。可是蛋疼的B君此刻突然不想看这个函数了，他对另一个叫foo2的函数产生了更浓厚的兴趣。\r\n怎么办呢？如果把以上新增加的代码复制到foo2里，这就犯了大忌了~复制什么的难道不是最讨厌了么！而且，如果B君继续看了其他的函数呢？\r\n1.2. 以不变应万变，是变也\r\n\r\n还记得吗，函数在Python中是一等公民，那么我们可以考虑重新定义一个函数timeit，将foo的引用传递给他，然后在timeit中调用foo并进行计时，这样，我们就达到了不改动foo定义的目的，而且，不论B君看了多少个函数，我们都不用去修改函数定义了！\r\n\r\n    import time\r\n     \r\n    def foo():\r\n        print \'in foo()\'\r\n     \r\n    def timeit(func):\r\n        start = time.clock()\r\n        func()\r\n        end =time.clock()\r\n        print \'used:\', end - start\r\n     \r\n    timeit(foo)\r\n看起来逻辑上并没有问题，一切都很美好并且运作正常！……等等，我们似乎修改了调用部分的代码。原本我们是这样调用的：foo()，修改以后变成了：timeit(foo)。这样的话，如果foo在N处都被调用了，你就不得不去修改这N处的代码。或者更极端的，考虑其中某处调用的代码无法修改这个情况，比如：这个函数是你交给别人使用的。\r\n1.3. 最大限度地少改动！\r\n\r\n既然如此，我们就来想想办法不修改调用的代码；如果不修改调用代码，也就意味着调用foo()需要产生调用timeit(foo)的效果。我们可以想到将timeit赋值给foo，但是timeit似乎带有一个参数……想办法把参数统一吧！如果timeit(foo)不是直接产生调用效果，而是返回一个与foo参数列表一致的函数的话……就很好办了，将timeit(foo)的返回值赋值给foo，然后，调用foo()的代码完全不用修改！\r\n\r\n    #-*- coding: UTF-8 -*-\r\n    import time\r\n     \r\n    def foo():\r\n        print \'in foo()\'\r\n     \r\n    # 定义一个计时器，传入一个，并返回另一个附加了计时功能的方法\r\n    def timeit(func):\r\n         \r\n        # 定义一个内嵌的包装函数，给传入的函数加上计时功能的包装\r\n        def wrapper():\r\n            start = time.clock()\r\n            func()\r\n            end =time.clock()\r\n            print \'used:\', end - start\r\n         \r\n        # 将包装后的函数返回\r\n        return wrapper\r\n     \r\n    foo = timeit(foo)\r\n    foo()\r\n\r\n这样，一个简易的计时器就做好了！我们只需要在定义foo以后调用foo之前，加上foo = timeit(foo)，就可以达到计时的目的，这也就是装饰器的概念，看起来像是foo被timeit装饰了。在在这个例子中，函数进入和退出时需要计时，这被称为一个横切面(Aspect)，这种编程方式被称为面向切面的编程(Aspect-Oriented Programming)。与传统编程习惯的从上往下执行方式相比较而言，像是在函数执行的流程中横向地插入了一段逻辑。在特定的业务领域里，能减少大量重复代码。面向切面编程还有相当多的术语，这里就不多做介绍，感兴趣的话可以去找找相关的资料。\r\n这个例子仅用于演示，并没有考虑foo带有参数和有返回值的情况，完善它的重任就交给你了 ：）\r\n上面这段代码看起来似乎已经不能再精简了，Python于是提供了一个语法糖来降低字符输入量。\r\n\r\n    import time\r\n     \r\n    def timeit(func):\r\n        def wrapper():\r\n            start = time.clock()\r\n            func()\r\n            end =time.clock()\r\n            print \'used:\', end - start\r\n        return wrapper\r\n     \r\n    @timeit\r\n    def foo():\r\n        print \'in foo()\'\r\n     \r\n    foo()\r\n\r\n重点关注第11行的@timeit，在定义上加上这一行与另外写foo = timeit(foo)完全等价，千万不要以为@有另外的魔力。除了字符输入少了一些，还有一个额外的好处：这样看上去更有装饰器的感觉。\r\n\r\n要理解python的装饰器，我们首先必须明白在Python中函数也是被视为对象。这一点很重要。先看一个例子：\r\n\r\n    def shout(word=\"yes\") :\r\n        return word.capitalize()+\" !\"\r\n     \r\n    print shout()\r\n    # 输出 : \'Yes !\'\r\n     \r\n    # 作为一个对象，你可以把函数赋给任何其他对象变量 \r\n     \r\n    scream = shout\r\n     \r\n    # 注意我们没有使用圆括号，因为我们不是在调用函数\r\n    # 我们把函数shout赋给scream，也就是说你可以通过scream调用shout\r\n     \r\n    print scream()\r\n    # 输出 : \'Yes !\'\r\n     \r\n    # 还有，你可以删除旧的名字shout，但是你仍然可以通过scream来访问该函数\r\n     \r\n    del shout\r\n    try :\r\n        print shout()\r\n    except NameError, e :\r\n        print e\r\n        #输出 : \"name \'shout\' is not defined\"\r\n     \r\n    print scream()\r\n    # 输出 : \'Yes !\'\r\n    我们暂且把这个话题放旁边，我们先看看python另外一个很有意思的属性：可以在函数中定义函数：\r\n    def talk() :\r\n     \r\n        # 你可以在talk中定义另外一个函数\r\n        def whisper(word=\"yes\") :\r\n            return word.lower()+\"...\";\r\n     \r\n        # ... 并且立马使用它\r\n     \r\n        print whisper()\r\n     \r\n    # 你每次调用\'talk\'，定义在talk里面的whisper同样也会被调用\r\n    talk()\r\n    # 输出 :\r\n    # yes...\r\n     \r\n    # 但是\"whisper\" 不会单独存在:\r\n     \r\n    try :\r\n        print whisper()\r\n    except NameError, e :\r\n        print e\r\n        #输出 : \"name \'whisper\' is not defined\"*\r\n\r\n函数引用\r\n从以上两个例子我们可以得出，函数既然作为一个对象，因此：\r\n1. 其可以被赋给其他变量\r\n2. 其可以被定义在另外一个函数内\r\n这也就是说，函数可以返回一个函数，看下面的例子：\r\n    def getTalk(type=\"shout\") :\r\n     \r\n        # 我们定义另外一个函数\r\n        def shout(word=\"yes\") :\r\n            return word.capitalize()+\" !\"\r\n     \r\n        def whisper(word=\"yes\") :\r\n            return word.lower()+\"...\";\r\n     \r\n        # 然后我们返回其中一个\r\n        if type == \"shout\" :\r\n            # 我们没有使用(),因为我们不是在调用该函数\r\n            # 我们是在返回该函数\r\n            return shout\r\n        else :\r\n            return whisper\r\n \r\n然后怎么使用呢 ?\r\n把该函数赋予某个变量\r\ntalk = getTalk()     \r\n \r\n这里你可以看到talk其实是一个函数对象:\r\nprint talk\r\n输出 : <function shout at 0xb7ea817c>\r\n \r\n该对象由函数返回的其中一个对象:\r\nprint talk()\r\n \r\n或者你可以直接如下调用 :\r\nprint getTalk(\"whisper\")()\r\n输出 : yes...\r\n还有，既然可以返回一个函数，我们可以把它作为参数传递给函数：\r\n    def doSomethingBefore(func) :\r\n        print \"I do something before then I call the function you gave me\"\r\n        print func()\r\n     \r\n    doSomethingBefore(scream)\r\n    #输出 :\r\n    #I do something before then I call the function you gave me\r\n    #Yes !\r\n\r\n这里你已经足够能理解装饰器了，其他它可被视为封装器。也就是说，它能够让你在装饰前后执行代码而无须改变函数本身内容。\r\n手工装饰\r\n那么如何进行手动装饰呢？\r\n    # 装饰器是一个函数，而其参数为另外一个函数\r\n    def my_shiny_new_decorator(a_function_to_decorate) :\r\n     \r\n        # 在内部定义了另外一个函数：一个封装器。\r\n        # 这个函数将原始函数进行封装，所以你可以在它之前或者之后执行一些代码\r\n        def the_wrapper_around_the_original_function() :\r\n     \r\n            # 放一些你希望在真正函数执行前的一些代码\r\n            print \"Before the function runs\"\r\n     \r\n            # 执行原始函数\r\n            a_function_to_decorate()\r\n     \r\n            # 放一些你希望在原始函数执行后的一些代码\r\n            print \"After the function runs\"\r\n     \r\n        #在此刻，\"a_function_to_decrorate\"还没有被执行，我们返回了创建的封装函数\r\n        #封装器包含了函数以及其前后执行的代码，其已经准备完毕\r\n        return the_wrapper_around_the_original_function\r\n \r\n现在想象下，你创建了一个你永远也不远再次接触的函数\r\n\r\n    def a_stand_alone_function() :\r\n        print \"I am a stand alone function, don\'t you dare modify me\"\r\n     \r\n    a_stand_alone_function()\r\n    #输出: I am a stand alone function, don\'t you dare modify me\r\n     \r\n    # 好了，你可以封装它实现行为的扩展。可以简单的把它丢给装饰器\r\n    # 装饰器将动态地把它和你要的代码封装起来，并且返回一个新的可用的函数。\r\n    a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)\r\n    a_stand_alone_function_decorated()\r\n    #输出 :\r\n    #Before the function runs\r\n    #I am a stand alone function, don\'t you dare modify me\r\n    #After the function runs\r\n\r\n现在你也许要求当每次调用a_stand_alone_function时，实际调用却是a_stand_alone_function_decorated。实现也很简单，可以用my_shiny_new_decorator来给a_stand_alone_function重新赋值。\r\n    a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)\r\n    a_stand_alone_function()\r\n    #输出 :\r\n    #Before the function runs\r\n    #I am a stand alone function, don\'t you dare modify me\r\n    #After the function runs\r\n     \r\n    # And guess what, that\'s EXACTLY what decorators do !\r\n\r\n装饰器揭秘\r\n前面的例子，我们可以使用装饰器的语法：\r\n    @my_shiny_new_decorator\r\n    def another_stand_alone_function() :\r\n        print \"Leave me alone\"\r\n     \r\n    another_stand_alone_function()\r\n    #输出 :\r\n    #Before the function runs\r\n    #Leave me alone\r\n    #After the function runs\r\n    当然你也可以累积装饰：\r\n    def bread(func) :\r\n        def wrapper() :\r\n            print \"</\'\'\'\'\'\'\\>\"\r\n            func()\r\n            print \"<\\______/>\"\r\n        return wrapper\r\n     \r\n    def ingredients(func) :\r\n        def wrapper() :\r\n            print \"#tomatoes#\"\r\n            func()\r\n            print \"~salad~\"\r\n        return wrapper\r\n     \r\n    def sandwich(food=\"--ham--\") :\r\n        print food\r\n     \r\n    sandwich()\r\n    #输出 : --ham--\r\n    sandwich = bread(ingredients(sandwich))\r\n    sandwich()\r\n    #outputs :\r\n    #</\'\'\'\'\'\'\\>\r\n    # #tomatoes#\r\n    # --ham--\r\n    # ~salad~\r\n    #<\\______/>\r\n    使用python装饰器语法：\r\n    @bread\r\n    @ingredients\r\n    def sandwich(food=\"--ham--\") :\r\n        print food\r\n     \r\n    sandwich()\r\n    #输出 :\r\n    #</\'\'\'\'\'\'\\>\r\n    # #tomatoes#\r\n    # --ham--\r\n    # ~salad~\r\n    #<\\______/>\r\n    装饰器的顺序很重要，需要注意：\r\n    @ingredients\r\n    @bread\r\n    def strange_sandwich(food=\"--ham--\") :\r\n        print food\r\n     \r\n    strange_sandwich()\r\n    #输出 :\r\n    ##tomatoes#\r\n    #</\'\'\'\'\'\'\\>\r\n    # --ham--\r\n    #<\\______/>\r\n    # ~salad~\r\n    最后回答前面提到的问题：\r\n    # 装饰器makebold用于转换为粗体\r\n    def makebold(fn):\r\n        # 结果返回该函数\r\n        def wrapper():\r\n            # 插入一些执行前后的代码\r\n            return \"<b>\" + fn() + \"</b>\"\r\n        return wrapper\r\n     \r\n    # 装饰器makeitalic用于转换为斜体\r\n    def makeitalic(fn):\r\n        # 结果返回该函数\r\n        def wrapper():\r\n            # 插入一些执行前后的代码\r\n            return \"<i>\" + fn() + \"</i>\"\r\n        return wrapper\r\n     \r\n    @makebold\r\n    @makeitalic\r\n    def say():\r\n        return \"hello\"\r\n     \r\n    print say()\r\n    #输出: <b><i>hello</i></b>\r\n     \r\n    # 等同于\r\n    def say():\r\n        return \"hello\"\r\n    say = makebold(makeitalic(say))\r\n     \r\n    print say()\r\n    #输出: <b><i>hello</i></b>\r\n\r\n内置的装饰器\r\n\r\n内置的装饰器有三个，分别是staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。由于模块里可以定义函数，所以静态方法和类方法的用处并不是太多，除非你想要完全的面向对象编程。而属性也不是不可或缺的，Java没有属性也一样活得很滋润。从我个人的Python经验来看，我没有使用过property，使用staticmethod和classmethod的频率也非常低。\r\n    class Rabbit(object):\r\n         \r\n        def __init__(self, name):\r\n            self._name = name\r\n         \r\n        @staticmethod\r\n        def newRabbit(name):\r\n            return Rabbit(name)\r\n         \r\n        @classmethod\r\n        def newRabbit2(cls):\r\n            return Rabbit(\'\')\r\n         \r\n        @property\r\n        def name(self):\r\n            return self._name\r\n    这里定义的属性是一个只读属性，如果需要可写，则需要再定义一个setter：\r\n    @name.setter\r\n    def name(self, name):\r\n        self._name = name\r\n\r\nfunctools模块\r\n\r\nfunctools模块提供了两个装饰器。这个模块是Python 2.5后新增的，一般来说大家用的应该都高于这个版本。但我平时的工作环境是2.4 T-T\r\n2.3.1. wraps(wrapped[, assigned][, updated]): \r\n这是一个很有用的装饰器。看过前一篇反射的朋友应该知道，函数是有几个特殊属性比如函数名，在被装饰后，上例中的函数名foo会变成包装函数的名字wrapper，如果你希望使用反射，可能会导致意外的结果。这个装饰器可以解决这个问题，它能将装饰过的函数的特殊属性保留。\r\n    import time\r\n    import functools\r\n     \r\n    def timeit(func):\r\n        @functools.wraps(func)\r\n        def wrapper():\r\n            start = time.clock()\r\n            func()\r\n            end =time.clock()\r\n            print \'used:\', end - start\r\n        return wrapper\r\n     \r\n    @timeit\r\n    def foo():\r\n        print \'in foo()\'\r\n     \r\n    foo()\r\n    print foo.__name__\r\n首先注意第5行，如果注释这一行，foo.__name__将是\'wrapper\'。另外相信你也注意到了，这个装饰器竟然带有一个参数。实际上，他还有另外两个可选的参数，assigned中的属性名将使用赋值的方式替换，而updated中的属性名将使用update的方式合并，你可以通过查看functools的源代码获得它们的默认值。对于这个装饰器，相当于wrapper = functools.wraps(func)(wrapper)。\r\n2.3.2. total_ordering(cls): \r\n这个装饰器在特定的场合有一定用处，但是它是在Python 2.7后新增的。它的作用是为实现了至少__lt__、__le__、__gt__、__ge__其中一个的类加上其他的比较方法，这是一个类装饰器。如果觉得不好理解，不妨仔细看看这个装饰器的源代码：\r\n\r\n    def total_ordering(cls):\r\n        \"\"\"Class decorator that fills in missing ordering methods\"\"\"\r\n        convert = {\r\n            \'__lt__\': [(\'__gt__\', lambda self, other: other < self),\r\n                       (\'__le__\', lambda self, other: not other < self),\r\n                       (\'__ge__\', lambda self, other: not self < other)],\r\n            \'__le__\': [(\'__ge__\', lambda self, other: other <= self),\r\n                       (\'__lt__\', lambda self, other: not other <= self),\r\n                       (\'__gt__\', lambda self, other: not self <= other)],\r\n            \'__gt__\': [(\'__lt__\', lambda self, other: other > self),\r\n                       (\'__ge__\', lambda self, other: not other > self),\r\n                       (\'__le__\', lambda self, other: not self > other)],\r\n            \'__ge__\': [(\'__le__\', lambda self, other: other >= self),\r\n                       (\'__gt__\', lambda self, other: not other >= self),\r\n                       (\'__lt__\', lambda self, other: not self >= other)]\r\n        }\r\n        roots = set(dir(cls)) & set(convert)\r\n        if not roots:\r\n            raise ValueError(\'must define at least one ordering operation: < > <= >=\')\r\n        root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__\r\n        for opname, opfunc in convert[root]:\r\n            if opname not in roots:\r\n                opfunc.__name__ = opname\r\n                opfunc.__doc__ = getattr(int, opname).__doc__\r\n                setattr(cls, opname, opfunc)\r\n        return cls\r\n','2016-07-05 12:42:25',1,'<p>转自 <a href=\"http://www.cnblogs.com/rollenholt/archive/2012/05/02/2479833.html\" rel=\"nofollow\">http://www.cnblogs.com/rollenholt/archive/2012/05/02/2479833.html</a></p>\n<p>文章先由stackoverflow上面的一个问题引起吧，如果使用如下的代码：</p>\n<pre><code>@makebold\n@makeitalic\ndef say():\n   return \"Hello\"\n打印出如下的输出：\n&lt;b&gt;&lt;i&gt;Hello&lt;i&gt;&lt;/b&gt;\n你会怎么做？最后给出的答案是：\ndef makebold(fn):\n    def wrapped():\n        return \"&lt;b&gt;\" + fn() + \"&lt;/b&gt;\"\n    return wrapped\n\ndef makeitalic(fn):\n    def wrapped():\n        return \"&lt;i&gt;\" + fn() + \"&lt;/i&gt;\"\n    return wrapped\n\n@makebold\n@makeitalic\ndef hello():\n    return \"hello world\"\n\nprint hello() ## 返回 &lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;\n</code></pre>\n<p>现在我们来看看如何从一些最基础的方式来理解Python的装饰器。英文讨论参考Here。\n装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。\n1.1. 需求是怎么来的？</p>\n<p>装饰器的定义很是抽象，我们来看一个小例子。</p>\n<pre><code>def foo():\n    print \'in foo()\'\nfoo()\n</code></pre>\n<p>这是一个很无聊的函数没错。但是突然有一个更无聊的人，我们称呼他为B君，说我想看看执行这个函数用了多长时间，好吧，那么我们可以这样做：</p>\n<pre><code>import time\ndef foo():\n    start = time.clock()\n    print \'in foo()\'\n    end = time.clock()\n    print \'used:\', end - start\n\nfoo()\n</code></pre>\n<p>很好，功能看起来无懈可击。可是蛋疼的B君此刻突然不想看这个函数了，他对另一个叫foo2的函数产生了更浓厚的兴趣。\n怎么办呢？如果把以上新增加的代码复制到foo2里，这就犯了大忌了~复制什么的难道不是最讨厌了么！而且，如果B君继续看了其他的函数呢？\n1.2. 以不变应万变，是变也</p>\n<p>还记得吗，函数在Python中是一等公民，那么我们可以考虑重新定义一个函数timeit，将foo的引用传递给他，然后在timeit中调用foo并进行计时，这样，我们就达到了不改动foo定义的目的，而且，不论B君看了多少个函数，我们都不用去修改函数定义了！</p>\n<pre><code>import time\n\ndef foo():\n    print \'in foo()\'\n\ndef timeit(func):\n    start = time.clock()\n    func()\n    end =time.clock()\n    print \'used:\', end - start\n\ntimeit(foo)\n</code></pre>\n<p>看起来逻辑上并没有问题，一切都很美好并且运作正常！……等等，我们似乎修改了调用部分的代码。原本我们是这样调用的：foo()，修改以后变成了：timeit(foo)。这样的话，如果foo在N处都被调用了，你就不得不去修改这N处的代码。或者更极端的，考虑其中某处调用的代码无法修改这个情况，比如：这个函数是你交给别人使用的。\n1.3. 最大限度地少改动！</p>\n<p>既然如此，我们就来想想办法不修改调用的代码；如果不修改调用代码，也就意味着调用foo()需要产生调用timeit(foo)的效果。我们可以想到将timeit赋值给foo，但是timeit似乎带有一个参数……想办法把参数统一吧！如果timeit(foo)不是直接产生调用效果，而是返回一个与foo参数列表一致的函数的话……就很好办了，将timeit(foo)的返回值赋值给foo，然后，调用foo()的代码完全不用修改！</p>\n<pre><code>#-*- coding: UTF-8 -*-\nimport time\n\ndef foo():\n    print \'in foo()\'\n\n# 定义一个计时器，传入一个，并返回另一个附加了计时功能的方法\ndef timeit(func):\n\n    # 定义一个内嵌的包装函数，给传入的函数加上计时功能的包装\n    def wrapper():\n        start = time.clock()\n        func()\n        end =time.clock()\n        print \'used:\', end - start\n\n    # 将包装后的函数返回\n    return wrapper\n\nfoo = timeit(foo)\nfoo()\n</code></pre>\n<p>这样，一个简易的计时器就做好了！我们只需要在定义foo以后调用foo之前，加上foo = timeit(foo)，就可以达到计时的目的，这也就是装饰器的概念，看起来像是foo被timeit装饰了。在在这个例子中，函数进入和退出时需要计时，这被称为一个横切面(Aspect)，这种编程方式被称为面向切面的编程(Aspect-Oriented Programming)。与传统编程习惯的从上往下执行方式相比较而言，像是在函数执行的流程中横向地插入了一段逻辑。在特定的业务领域里，能减少大量重复代码。面向切面编程还有相当多的术语，这里就不多做介绍，感兴趣的话可以去找找相关的资料。\n这个例子仅用于演示，并没有考虑foo带有参数和有返回值的情况，完善它的重任就交给你了 ：）\n上面这段代码看起来似乎已经不能再精简了，Python于是提供了一个语法糖来降低字符输入量。</p>\n<pre><code>import time\n\ndef timeit(func):\n    def wrapper():\n        start = time.clock()\n        func()\n        end =time.clock()\n        print \'used:\', end - start\n    return wrapper\n\n@timeit\ndef foo():\n    print \'in foo()\'\n\nfoo()\n</code></pre>\n<p>重点关注第11行的@timeit，在定义上加上这一行与另外写foo = timeit(foo)完全等价，千万不要以为@有另外的魔力。除了字符输入少了一些，还有一个额外的好处：这样看上去更有装饰器的感觉。</p>\n<p>要理解python的装饰器，我们首先必须明白在Python中函数也是被视为对象。这一点很重要。先看一个例子：</p>\n<pre><code>def shout(word=\"yes\") :\n    return word.capitalize()+\" !\"\n\nprint shout()\n# 输出 : \'Yes !\'\n\n# 作为一个对象，你可以把函数赋给任何其他对象变量\n\nscream = shout\n\n# 注意我们没有使用圆括号，因为我们不是在调用函数\n# 我们把函数shout赋给scream，也就是说你可以通过scream调用shout\n\nprint scream()\n# 输出 : \'Yes !\'\n\n# 还有，你可以删除旧的名字shout，但是你仍然可以通过scream来访问该函数\n\ndel shout\ntry :\n    print shout()\nexcept NameError, e :\n    print e\n    #输出 : \"name \'shout\' is not defined\"\n\nprint scream()\n# 输出 : \'Yes !\'\n我们暂且把这个话题放旁边，我们先看看python另外一个很有意思的属性：可以在函数中定义函数：\ndef talk() :\n\n    # 你可以在talk中定义另外一个函数\n    def whisper(word=\"yes\") :\n        return word.lower()+\"...\";\n\n    # ... 并且立马使用它\n\n    print whisper()\n\n# 你每次调用\'talk\'，定义在talk里面的whisper同样也会被调用\ntalk()\n# 输出 :\n# yes...\n\n# 但是\"whisper\" 不会单独存在:\n\ntry :\n    print whisper()\nexcept NameError, e :\n    print e\n    #输出 : \"name \'whisper\' is not defined\"*\n</code></pre>\n<p>函数引用\n从以上两个例子我们可以得出，函数既然作为一个对象，因此：\n1. 其可以被赋给其他变量\n2. 其可以被定义在另外一个函数内\n这也就是说，函数可以返回一个函数，看下面的例子：\n    def getTalk(type=\"shout\") :</p>\n<pre><code>    # 我们定义另外一个函数\n    def shout(word=\"yes\") :\n        return word.capitalize()+\" !\"\n\n    def whisper(word=\"yes\") :\n        return word.lower()+\"...\";\n\n    # 然后我们返回其中一个\n    if type == \"shout\" :\n        # 我们没有使用(),因为我们不是在调用该函数\n        # 我们是在返回该函数\n        return shout\n    else :\n        return whisper\n</code></pre>\n<p>然后怎么使用呢 ?\n把该函数赋予某个变量\ntalk = getTalk()     </p>\n<p>这里你可以看到talk其实是一个函数对象:\nprint talk\n输出 : </p>\n<p>该对象由函数返回的其中一个对象:\nprint talk()</p>\n<p>或者你可以直接如下调用 :\nprint getTalk(\"whisper\")()\n输出 : yes...\n还有，既然可以返回一个函数，我们可以把它作为参数传递给函数：\n    def doSomethingBefore(func) :\n        print \"I do something before then I call the function you gave me\"\n        print func()</p>\n<pre><code>doSomethingBefore(scream)\n#输出 :\n#I do something before then I call the function you gave me\n#Yes !\n</code></pre>\n<p>这里你已经足够能理解装饰器了，其他它可被视为封装器。也就是说，它能够让你在装饰前后执行代码而无须改变函数本身内容。\n手工装饰\n那么如何进行手动装饰呢？\n    # 装饰器是一个函数，而其参数为另外一个函数\n    def my_shiny_new_decorator(a_function_to_decorate) :</p>\n<pre><code>    # 在内部定义了另外一个函数：一个封装器。\n    # 这个函数将原始函数进行封装，所以你可以在它之前或者之后执行一些代码\n    def the_wrapper_around_the_original_function() :\n\n        # 放一些你希望在真正函数执行前的一些代码\n        print \"Before the function runs\"\n\n        # 执行原始函数\n        a_function_to_decorate()\n\n        # 放一些你希望在原始函数执行后的一些代码\n        print \"After the function runs\"\n\n    #在此刻，\"a_function_to_decrorate\"还没有被执行，我们返回了创建的封装函数\n    #封装器包含了函数以及其前后执行的代码，其已经准备完毕\n    return the_wrapper_around_the_original_function\n</code></pre>\n<p>现在想象下，你创建了一个你永远也不远再次接触的函数</p>\n<pre><code>def a_stand_alone_function() :\n    print \"I am a stand alone function, don\'t you dare modify me\"\n\na_stand_alone_function()\n#输出: I am a stand alone function, don\'t you dare modify me\n\n# 好了，你可以封装它实现行为的扩展。可以简单的把它丢给装饰器\n# 装饰器将动态地把它和你要的代码封装起来，并且返回一个新的可用的函数。\na_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)\na_stand_alone_function_decorated()\n#输出 :\n#Before the function runs\n#I am a stand alone function, don\'t you dare modify me\n#After the function runs\n</code></pre>\n<p>现在你也许要求当每次调用a_stand_alone_function时，实际调用却是a_stand_alone_function_decorated。实现也很简单，可以用my_shiny_new_decorator来给a_stand_alone_function重新赋值。\n    a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)\n    a_stand_alone_function()\n    #输出 :\n    #Before the function runs\n    #I am a stand alone function, don\'t you dare modify me\n    #After the function runs</p>\n<pre><code># And guess what, that\'s EXACTLY what decorators do !\n</code></pre>\n<p>装饰器揭秘\n前面的例子，我们可以使用装饰器的语法：\n    @my_shiny_new_decorator\n    def another_stand_alone_function() :\n        print \"Leave me alone\"</p>\n<pre><code>another_stand_alone_function()\n#输出 :\n#Before the function runs\n#Leave me alone\n#After the function runs\n当然你也可以累积装饰：\ndef bread(func) :\n    def wrapper() :\n        print \"&lt;/\'\'\'\'\'\'\\&gt;\"\n        func()\n        print \"&lt;\\______/&gt;\"\n    return wrapper\n\ndef ingredients(func) :\n    def wrapper() :\n        print \"#tomatoes#\"\n        func()\n        print \"~salad~\"\n    return wrapper\n\ndef sandwich(food=\"--ham--\") :\n    print food\n\nsandwich()\n#输出 : --ham--\nsandwich = bread(ingredients(sandwich))\nsandwich()\n#outputs :\n#&lt;/\'\'\'\'\'\'\\&gt;\n# #tomatoes#\n# --ham--\n# ~salad~\n#&lt;\\______/&gt;\n使用python装饰器语法：\n@bread\n@ingredients\ndef sandwich(food=\"--ham--\") :\n    print food\n\nsandwich()\n#输出 :\n#&lt;/\'\'\'\'\'\'\\&gt;\n# #tomatoes#\n# --ham--\n# ~salad~\n#&lt;\\______/&gt;\n装饰器的顺序很重要，需要注意：\n@ingredients\n@bread\ndef strange_sandwich(food=\"--ham--\") :\n    print food\n\nstrange_sandwich()\n#输出 :\n##tomatoes#\n#&lt;/\'\'\'\'\'\'\\&gt;\n# --ham--\n#&lt;\\______/&gt;\n# ~salad~\n最后回答前面提到的问题：\n# 装饰器makebold用于转换为粗体\ndef makebold(fn):\n    # 结果返回该函数\n    def wrapper():\n        # 插入一些执行前后的代码\n        return \"&lt;b&gt;\" + fn() + \"&lt;/b&gt;\"\n    return wrapper\n\n# 装饰器makeitalic用于转换为斜体\ndef makeitalic(fn):\n    # 结果返回该函数\n    def wrapper():\n        # 插入一些执行前后的代码\n        return \"&lt;i&gt;\" + fn() + \"&lt;/i&gt;\"\n    return wrapper\n\n@makebold\n@makeitalic\ndef say():\n    return \"hello\"\n\nprint say()\n#输出: &lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;\n\n# 等同于\ndef say():\n    return \"hello\"\nsay = makebold(makeitalic(say))\n\nprint say()\n#输出: &lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;\n</code></pre>\n<p>内置的装饰器</p>\n<p>内置的装饰器有三个，分别是staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。由于模块里可以定义函数，所以静态方法和类方法的用处并不是太多，除非你想要完全的面向对象编程。而属性也不是不可或缺的，Java没有属性也一样活得很滋润。从我个人的Python经验来看，我没有使用过property，使用staticmethod和classmethod的频率也非常低。\n    class Rabbit(object):</p>\n<pre><code>    def __init__(self, name):\n        self._name = name\n\n    @staticmethod\n    def newRabbit(name):\n        return Rabbit(name)\n\n    @classmethod\n    def newRabbit2(cls):\n        return Rabbit(\'\')\n\n    @property\n    def name(self):\n        return self._name\n这里定义的属性是一个只读属性，如果需要可写，则需要再定义一个setter：\n@name.setter\ndef name(self, name):\n    self._name = name\n</code></pre>\n<p>functools模块</p>\n<p>functools模块提供了两个装饰器。这个模块是Python 2.5后新增的，一般来说大家用的应该都高于这个版本。但我平时的工作环境是2.4 T-T\n2.3.1. wraps(wrapped[, assigned][, updated]): \n这是一个很有用的装饰器。看过前一篇反射的朋友应该知道，函数是有几个特殊属性比如函数名，在被装饰后，上例中的函数名foo会变成包装函数的名字wrapper，如果你希望使用反射，可能会导致意外的结果。这个装饰器可以解决这个问题，它能将装饰过的函数的特殊属性保留。\n    import time\n    import functools</p>\n<pre><code>def timeit(func):\n    @functools.wraps(func)\n    def wrapper():\n        start = time.clock()\n        func()\n        end =time.clock()\n        print \'used:\', end - start\n    return wrapper\n\n@timeit\ndef foo():\n    print \'in foo()\'\n\nfoo()\nprint foo.__name__\n</code></pre>\n<p>首先注意第5行，如果注释这一行，foo.<strong>name</strong>将是\'wrapper\'。另外相信你也注意到了，这个装饰器竟然带有一个参数。实际上，他还有另外两个可选的参数，assigned中的属性名将使用赋值的方式替换，而updated中的属性名将使用update的方式合并，你可以通过查看functools的源代码获得它们的默认值。对于这个装饰器，相当于wrapper = functools.wraps(func)(wrapper)。\n2.3.2. total_ordering(cls): \n这个装饰器在特定的场合有一定用处，但是它是在Python 2.7后新增的。它的作用是为实现了至少<strong>lt</strong>、<strong>le</strong>、<strong>gt</strong>、<strong>ge</strong>其中一个的类加上其他的比较方法，这是一个类装饰器。如果觉得不好理解，不妨仔细看看这个装饰器的源代码：</p>\n<pre><code>def total_ordering(cls):\n    \"\"\"Class decorator that fills in missing ordering methods\"\"\"\n    convert = {\n        \'__lt__\': [(\'__gt__\', lambda self, other: other &lt; self),\n                   (\'__le__\', lambda self, other: not other &lt; self),\n                   (\'__ge__\', lambda self, other: not self &lt; other)],\n        \'__le__\': [(\'__ge__\', lambda self, other: other &lt;= self),\n                   (\'__lt__\', lambda self, other: not other &lt;= self),\n                   (\'__gt__\', lambda self, other: not self &lt;= other)],\n        \'__gt__\': [(\'__lt__\', lambda self, other: other &gt; self),\n                   (\'__ge__\', lambda self, other: not other &gt; self),\n                   (\'__le__\', lambda self, other: not self &gt; other)],\n        \'__ge__\': [(\'__le__\', lambda self, other: other &gt;= self),\n                   (\'__gt__\', lambda self, other: not other &gt;= self),\n                   (\'__lt__\', lambda self, other: not self &gt;= other)]\n    }\n    roots = set(dir(cls)) &amp; set(convert)\n    if not roots:\n        raise ValueError(\'must define at least one ordering operation: &lt; &gt; &lt;= &gt;=\')\n    root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__\n    for opname, opfunc in convert[root]:\n        if opname not in roots:\n            opfunc.__name__ = opname\n            opfunc.__doc__ = getattr(int, opname).__doc__\n            setattr(cls, opname, opfunc)\n    return cls\n</code></pre>','理解Python中的装饰器','理解Python中的装饰器'),(17,'    字符串格式化替代操作\r\n    >>>\'%s,eggs,and %s\' % (\'spam\',\'SPAM\')\r\n    \'spam,eggs,and SPAM\'\r\n    >>>\'{0},eggs,and {1}\'.format(\'spam\',\'SPAM\')\r\n    \'spam,eggs,and SPAM\'\r\n    \r\n    >>> food = \'spam\'\r\n    >>> age = 40\r\n    >>> vars()\r\n    {\'food\': \'spam\', \'age\': 40, ...many more... }\r\n    \r\n    >>> \"%(age)d %(food)s\" % vars()\r\n    \'40 spam\'\r\n    \r\n    >>> template = \'{0}, {1} and {2}\'                    # By position\r\n    >>> template.format(\'spam\', \'ham\', \'eggs\')\r\n    \'spam, ham and eggs\'\r\n    \r\n    >>> template = \'{motto}, {pork} and {food}\'          # By keyword\r\n    >>> template.format(motto=\'spam\', pork=\'ham\', food=\'eggs\')\r\n    \'spam, ham and eggs\'\r\n    \r\n    >>> template = \'{motto}, {0} and {food}\'             # By both\r\n    >>> template.format(\'ham\', motto=\'spam\', food=\'eggs\')\r\n    \'spam, ham and eggs\'\r\n    \r\n    >>> \'{motto}, {0} and {food}\'.format(42, motto=3.14, food=[1, 2])\r\n    \'3.14, 42 and [1, 2]\'\r\n    \r\n    >>> import sys\r\n    >>> \'My {1[spam]} runs {0.platform}\'.format(sys, {\'spam\': \'laptop\'})\r\n    \'My laptop runs win32\'\r\n    \r\n    >>> \'My {config[spam]} runs {sys.platform}\'.format(sys=sys,\r\n                                                       config={\'spam\': \'laptop\'})\r\n    \'My laptop runs win32\'\r\n','2016-07-05 13:03:36',1,'<pre><code>字符串格式化替代操作\n&gt;&gt;&gt;\'%s,eggs,and %s\' % (\'spam\',\'SPAM\')\n\'spam,eggs,and SPAM\'\n&gt;&gt;&gt;\'{0},eggs,and {1}\'.format(\'spam\',\'SPAM\')\n\'spam,eggs,and SPAM\'\n\n&gt;&gt;&gt; food = \'spam\'\n&gt;&gt;&gt; age = 40\n&gt;&gt;&gt; vars()\n{\'food\': \'spam\', \'age\': 40, ...many more... }\n\n&gt;&gt;&gt; \"%(age)d %(food)s\" % vars()\n\'40 spam\'\n\n&gt;&gt;&gt; template = \'{0}, {1} and {2}\'                    # By position\n&gt;&gt;&gt; template.format(\'spam\', \'ham\', \'eggs\')\n\'spam, ham and eggs\'\n\n&gt;&gt;&gt; template = \'{motto}, {pork} and {food}\'          # By keyword\n&gt;&gt;&gt; template.format(motto=\'spam\', pork=\'ham\', food=\'eggs\')\n\'spam, ham and eggs\'\n\n&gt;&gt;&gt; template = \'{motto}, {0} and {food}\'             # By both\n&gt;&gt;&gt; template.format(\'ham\', motto=\'spam\', food=\'eggs\')\n\'spam, ham and eggs\'\n\n&gt;&gt;&gt; \'{motto}, {0} and {food}\'.format(42, motto=3.14, food=[1, 2])\n\'3.14, 42 and [1, 2]\'\n\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; \'My {1[spam]} runs {0.platform}\'.format(sys, {\'spam\': \'laptop\'})\n\'My laptop runs win32\'\n\n&gt;&gt;&gt; \'My {config[spam]} runs {sys.platform}\'.format(sys=sys,\n                                                   config={\'spam\': \'laptop\'})\n\'My laptop runs win32\'\n</code></pre>','Python 字符串格式化替代操作','Python 字符串格式化替代操作'),(18,' raw字符串抑制转义\r\n\r\n    myfile=open(\'c:\\new\\text.dat\',\'w\')\r\n    会将 \\n 识别为换行符，\\t识别为制表符\r\n    改为\r\n    myfile=open(r\'c:\\new\\text.dat\',\'w\')  就可以了\r\n    \r\n内置函数type\r\n\r\n    >>> type(L)                     # 3.0: types are classes, and vice versa\r\n    <class \'list\'>\r\n    >>> type(type(L))               # See Chapter 31 for more on class types\r\n    <class \'type\'>\r\n    \r\n    >>> if type(L) == type([]):     # Type testing, if you must...\r\n            print(\'yes\')\r\n    \r\n    yes\r\n    >>> if type(L) == list:         # Using the type name\r\n            print(\'yes\')\r\n    \r\n    yes\r\n    >>> if isinstance(L, list):     # Object-oriented tests\r\n            print(\'yes\')\r\n    \r\n    yes\r\n    \r\nPython 实例方法、@staticmethod和@classmethod  \r\nhttp://blog.csdn.net/lovingprince/article/details/6595466\r\n    \r\n    class Foo(object):  \r\n        def test(self)://定义了实例方法  \r\n            print(\"object\")  \r\n        @classmethod  \r\n        def test2(clss)://定义了类方法  \r\n            print(\"class\")  \r\n        @staticmethod  \r\n        def test3()://定义了静态方法  \r\n            print(\"static\")      ','2016-07-05 13:12:58',1,'<p>raw字符串抑制转义</p>\n<pre><code>myfile=open(\'c:\\new\\text.dat\',\'w\')\n会将 \\n 识别为换行符，\\t识别为制表符\n改为\nmyfile=open(r\'c:\\new\\text.dat\',\'w\')  就可以了\n</code></pre>\n<p>内置函数type</p>\n<pre><code>&gt;&gt;&gt; type(L)                     # 3.0: types are classes, and vice versa\n&lt;class \'list\'&gt;\n&gt;&gt;&gt; type(type(L))               # See Chapter 31 for more on class types\n&lt;class \'type\'&gt;\n\n&gt;&gt;&gt; if type(L) == type([]):     # Type testing, if you must...\n        print(\'yes\')\n\nyes\n&gt;&gt;&gt; if type(L) == list:         # Using the type name\n        print(\'yes\')\n\nyes\n&gt;&gt;&gt; if isinstance(L, list):     # Object-oriented tests\n        print(\'yes\')\n\nyes\n</code></pre>\n<p>Python 实例方法、@staticmethod和@classmethod<br>\n<a href=\"http://blog.csdn.net/lovingprince/article/details/6595466\" rel=\"nofollow\">http://blog.csdn.net/lovingprince/article/details/6595466</a></p>\n<pre><code>class Foo(object):  \n    def test(self)://定义了实例方法  \n        print(\"object\")  \n    @classmethod  \n    def test2(clss)://定义了类方法  \n        print(\"class\")  \n    @staticmethod  \n    def test3()://定义了静态方法  \n        print(\"static\")\n</code></pre>','Python 小技巧','raw字符串抑制转义'),(19,'import 模块名时，模块名不能加引号,但可如下实现\r\n\r\n    >>> modname = \"string\"\r\n    >>> exec(\"import \" + modname)      # Run a string of code\r\n    >>> string                         # Imported in this namespace\r\n    <module \'string\' from \'c:\\Python30\\lib\\string.py\'>\r\n    \r\n    >>> modname = \"string\"\r\n    >>> string = __import__(modname)\r\n    >>> string\r\n    <module \'string\' from \'c:\\Python30\\lib\\string.py\'>\r\n    \r\nimport 时，避免打印    if __name__ == \'__main__\': \r\n\r\n\r\n    class Person:\r\n       def __init__(self, name, job=None, pay=0):\r\n           self.name = name\r\n           self.job  = job\r\n           self.pay  = pay\r\n\r\n    f __name__ == \'__main__\':                  # When run for testing only\r\n       # self-test code\r\n       bob = Person(\'Bob Smith\')\r\n       sue = Person(\'Sue Jones\', job=\'dev\', pay=100000)\r\n       print(bob.name, bob.pay)\r\n       print(sue.name, sue.pay)\r\n\r\n\r\n运算符重载，提供打印显示   def __str__(self):\r\n\r\n    class Person:\r\n        def __init__(self, name, job=None, pay=0):\r\n            self.name = name\r\n            self.job  = job\r\n            self.pay  = pay\r\n        def lastName(self):\r\n            return self.name.split()[-1]\r\n        def giveRaise(self, percent):\r\n            self.pay = int(self.pay * (1 + percent))\r\n        def __str__(self):                                         # Added method\r\n            return \'[Person: %s, %s]\' % (self.name, self.pay)      # String to print\r\n    \r\n    if __name__ == \'__main__\':\r\n        bob = Person(\'Bob Smith\')\r\n        sue = Person(\'Sue Jones\', job=\'dev\', pay=100000)\r\n        print(bob)\r\n        print(sue)\r\n        print(bob.lastName(), sue.lastName())\r\n        sue.giveRaise(.10)\r\n        print(sue)\r\n\r\n\r\n向上查找一个属性，当这个属性没有在常规属性中找到时  \r\nCalled when an attribute lookup has not found the attribute in the usual places.\r\n\r\n    def __getattr__(self, attr):\r\n        return getattr(self.person, attr)           # Delegate all other attrs\r\n    def __str__(self):\r\n        return str(self.person)                     # Must overload again (in 3.0)\r\n\r\n\r\n4 使用内省工具(27章)\r\n\r\n    instance.__class__\r\n    instance.class.__name__\r\n    instance.class.__bases__\r\n    object.__dict__\r\n    object.__dict__.keys()\r\n    dir(instance)\r\n    ','2016-07-05 13:21:24',1,'<p>import 模块名时，模块名不能加引号,但可如下实现</p>\n<pre><code>&gt;&gt;&gt; modname = \"string\"\n&gt;&gt;&gt; exec(\"import \" + modname)      # Run a string of code\n&gt;&gt;&gt; string                         # Imported in this namespace\n&lt;module \'string\'=\"\" from=\"\" \'c:\\Python30\\lib\\&lt;a=\"\" href=\"&amp;lt;a href=\" http:=\"\" string.py\"=\"\" rel=\"nofollow\"&gt;http://string.py\" rel=\"nofollow\"&gt;<a href=\"http://string.py\" rel=\"nofollow\">string.py</a>\'&gt;\n\n&gt;&gt;&gt; modname = \"string\"\n&gt;&gt;&gt; string = __import__(modname)\n&gt;&gt;&gt; string\n&lt;module \'string\'=\"\" from=\"\" \'c:\\Python30\\lib\\&lt;a=\"\" href=\"&amp;lt;a href=\" http:=\"\" string.py\"=\"\" rel=\"nofollow\"&gt;http://string.py\" rel=\"nofollow\"&gt;<a href=\"http://string.py\" rel=\"nofollow\">string.py</a>\'&gt;\n</code></pre>\n<p>import 时，避免打印    if <strong>name</strong> == \'<strong>main</strong>\': </p>\n<pre><code>class Person:\n   def __init__(self, name, job=None, pay=0):\n       <a href=\"http://self.name\" rel=\"nofollow\">self.name</a> = name\n       self.job  = job\n       self.pay  = pay\n\nf __name__ == \'__main__\':                  # When run for testing only\n   # self-test code\n   bob = Person(\'Bob Smith\')\n   sue = Person(\'Sue Jones\', job=\'dev\', pay=100000)\n   print(<a href=\"http://bob.name\" rel=\"nofollow\">bob.name</a>, bob.pay)\n   print(<a href=\"http://sue.name\" rel=\"nofollow\">sue.name</a>, sue.pay)\n</code></pre>\n<p>运算符重载，提供打印显示   def <strong>str</strong>(self):</p>\n<pre><code>class Person:\n    def __init__(self, name, job=None, pay=0):\n        <a href=\"http://self.name\" rel=\"nofollow\">self.name</a> = name\n        self.job  = job\n        self.pay  = pay\n    def lastName(self):\n        return self.name.split()[-1]\n    def giveRaise(self, percent):\n        self.pay = int(self.pay * (1 + percent))\n    def __str__(self):                                         # Added method\n        return \'[Person: %s, %s]\' % (<a href=\"http://self.name\" rel=\"nofollow\">self.name</a>, self.pay)      # String to print\n\nif __name__ == \'__main__\':\n    bob = Person(\'Bob Smith\')\n    sue = Person(\'Sue Jones\', job=\'dev\', pay=100000)\n    print(bob)\n    print(sue)\n    print(bob.lastName(), sue.lastName())\n    sue.giveRaise(.10)\n    print(sue)\n</code></pre>\n<p>向上查找一个属性，当这个属性没有在常规属性中找到时<br>\nCalled when an attribute lookup has not found the attribute in the usual places.</p>\n<pre><code>def __getattr__(self, attr):\n    return getattr(self.person, attr)           # Delegate all other attrs\ndef __str__(self):\n    return str(self.person)                     # Must overload again (in 3.0)\n</code></pre>\n<p>4 使用内省工具(27章)</p>\n<pre><code>instance.__class__\ninstance.class.__name__\ninstance.class.__bases__\nobject.__dict__\nobject.__dict__.keys()\ndir(instance)\n</code></pre>','Python import 模块、属性','Python import 模块、属性'),(20,'普通方法，静态方法和类方法 \r\n\r\n原文 https://www.zhihu.com/question/20021164/answer/18224953\r\n\r\n类中最常用的方法是实例方法, 即通过通过实例作为第一个参数的方法。\r\n举个例子，一个基本的实例方法就向下面这个:\r\n \r\n    class Kls(object):\r\n        def __init__(self, data):\r\n            self.data = data\r\n        def printd(self):\r\n            print(self.data)\r\n    ik1 = Kls(\'arun\')\r\n    ik2 = Kls(\'seema\')\r\n    ik1.printd()\r\n    ik2.printd()\r\n    \r\n    这会给出如下的输出:\r\n    arun\r\n    seema\r\n\r\n\r\n\r\n参数传递给方法.\r\nself参数指向当前实例自身.\r\n我们不需要传递实例自身给方法，Python解释器自己会做这些操作的.\r\n\r\n如果现在我们想写一些仅仅与类交互而不是和实例交互的方法会怎么样呢? 我们可以在类外面写一个简单的方法来做这些，但是这样做就扩散了类代码的关系到类定义的外面. 如果像下面这样写就会导致以后代码维护的困难:\r\n\r\n \r\n    def get_no_of_instances(cls_obj):\r\n        return cls_obj.no_inst\r\n    class Kls(object):\r\n        no_inst = 0\r\n        def __init__(self):\r\n            Kls.no_inst = Kls.no_inst + 1\r\n    ik1 = Kls()\r\n    ik2 = Kls()\r\n    print(get_no_of_instances(Kls))\r\n    \r\n    输出:\r\n    2\r\n\r\n\r\n@classmethod\r\n我们要写一个只在类中运行而不在实例中运行的方法. 如果我们想让方法不在实例中运行，可以这么做:\r\n\r\n \r\n    def iget_no_of_instance(ins_obj):\r\n        return ins_obj.__class__.no_inst\r\n    class Kls(object):\r\n        no_inst = 0\r\n        def __init__(self):\r\n        Kls.no_inst = Kls.no_inst + 1\r\n    ik1 = Kls()\r\n    ik2 = Kls()\r\n    print iget_no_of_instance(ik1)\r\n    \r\n    输出\r\n    2\r\n\r\n\r\n在Python2.2以后可以使用@classmethod装饰器来创建类方法.\r\n\r\n \r\n    class Kls(object):\r\n        no_inst = 0\r\n        def __init__(self):\r\n            Kls.no_inst = Kls.no_inst + 1\r\n        @classmethod\r\n        def get_no_of_instance(cls_obj):\r\n            return cls_obj.no_inst\r\n    ik1 = Kls()\r\n    ik2 = Kls()\r\n    print ik1.get_no_of_instance()\r\n    print Kls.get_no_of_instance()\r\n    \r\n    输出:\r\n    2\r\n    2\r\n\r\n这样的好处是: 不管这个方式是从实例调用还是从类调用，它都用第一个参数把类传递过来.\r\n\r\n\r\n@staticmethod\r\n经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法. 比如更改环境变量或者修改其他类的属性等能用到静态方法. 这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难.\r\n比如这样:\r\n\r\n \r\n    IND = \'ON\'\r\n    def checkind():\r\n        return (IND == \'ON\')\r\n    class Kls(object):\r\n         def __init__(self,data):\r\n            self.data = data\r\n    def do_reset(self):\r\n        if checkind():\r\n            print(\'Reset done for:\', self.data)\r\n    def set_db(self):\r\n        if checkind():\r\n            self.db = \'new db connection\'\r\n            print(\'DB connection made for:\',self.data)\r\n    ik1 = Kls(12)\r\n    ik1.do_reset()\r\n    ik1.set_db()\r\n    \r\n    输出:\r\n    Reset done for: 12\r\n    DB connection made for: 12\r\n\r\n如果使用@staticmethod就能把相关的代码放到对应的位置了.\r\n \r\n    IND = \'ON\'\r\n    class Kls(object):\r\n        def __init__(self, data):\r\n            self.data = data\r\n        @staticmethod\r\n        def checkind():\r\n            return (IND == \'ON\')\r\n        def do_reset(self):\r\n            if self.checkind():\r\n                print(\'Reset done for:\', self.data)\r\n        def set_db(self):\r\n            if self.checkind():\r\n                self.db = \'New db connection\'\r\n            print(\'DB connection made for: \', self.data)\r\n    ik1 = Kls(12)\r\n    ik1.do_reset()\r\n    ik1.set_db()\r\n    \r\n    输出:\r\n    Reset done for: 12\r\n    DB connection made for: 12\r\n\r\n下面这个更全面的代码和图示来展示这两种方法的不同\r\n@staticmethod 和 @classmethod的不同\r\n\r\n \r\n    class Kls(object):\r\n        def __init__(self, data):\r\n            self.data = data\r\n        def printd(self):\r\n            print(self.data)\r\n        @staticmethod\r\n        def smethod(*arg):\r\n            print(\'Static:\', arg)\r\n        @classmethod\r\n        def cmethod(*arg):\r\n            print(\'Class:\', arg)\r\n     \r\n    >>> ik = Kls(23)\r\n    >>> ik.printd()\r\n    23\r\n    >>> ik.smethod()\r\n    Static: ()\r\n    >>> ik.cmethod()\r\n    Class: (<class \'__main__.Kls\'>,)\r\n    >>> Kls.printd()\r\n    TypeError: unbound method printd() must be called with Kls instance as first argument (got nothing instead)\r\n    >>> Kls.smethod()\r\n    Static: ()\r\n    >>> Kls.cmethod()\r\n    Class: (<class \'__main__.Kls\'>,)    \r\n\r\n\r\n@functools.wraps  \r\nhttps://docs.python.org/3.4/library/functools.html?highlight=functools#functools.partial\r\n\r\n    from functools import wraps\r\n    \r\n    def my_decorator(f):\r\n        @wraps(f)\r\n        def wrapper(*args, **kwds):\r\n            print(\'Calling decorated function\')\r\n            return f(*args, **kwds)\r\n        return wrapper\r\n    \r\n    @my_decorator\r\n    def example():\r\n        \"\"\"Docstring\"\"\"\r\n        print(\'Called example function\')\r\n    \r\n    example()\r\n    \r\n    example.__name__\r\n    \r\n    example.__doc__  ','2016-07-05 13:48:52',1,'<p>普通方法，静态方法和类方法 </p>\n<p>原文 <a href=\"https://www.zhihu.com/question/20021164/answer/18224953\" rel=\"nofollow\">https://www.zhihu.com/question/20021164/answer/18224953</a></p>\n<p>类中最常用的方法是实例方法, 即通过通过实例作为第一个参数的方法。\n举个例子，一个基本的实例方法就向下面这个:</p>\n<pre><code>class Kls(object):\n    def __init__(self, data):\n        self.data = data\n    def printd(self):\n        print(self.data)\nik1 = Kls(\'arun\')\nik2 = Kls(\'seema\')\nik1.printd()\nik2.printd()\n\n这会给出如下的输出:\narun\nseema\n</code></pre>\n<p>参数传递给方法.\nself参数指向当前实例自身.\n我们不需要传递实例自身给方法，Python解释器自己会做这些操作的.</p>\n<p>如果现在我们想写一些仅仅与类交互而不是和实例交互的方法会怎么样呢? 我们可以在类外面写一个简单的方法来做这些，但是这样做就扩散了类代码的关系到类定义的外面. 如果像下面这样写就会导致以后代码维护的困难:</p>\n<pre><code>def get_no_of_instances(cls_obj):\n    return cls_obj.no_inst\nclass Kls(object):\n    no_inst = 0\n    def __init__(self):\n        Kls.no_inst = Kls.no_inst + 1\nik1 = Kls()\nik2 = Kls()\nprint(get_no_of_instances(Kls))\n\n输出:\n2\n</code></pre>\n<p>@classmethod\n我们要写一个只在类中运行而不在实例中运行的方法. 如果我们想让方法不在实例中运行，可以这么做:</p>\n<pre><code>def iget_no_of_instance(ins_obj):\n    return ins_obj.__class__.no_inst\nclass Kls(object):\n    no_inst = 0\n    def __init__(self):\n    Kls.no_inst = Kls.no_inst + 1\nik1 = Kls()\nik2 = Kls()\nprint iget_no_of_instance(ik1)\n\n输出\n2\n</code></pre>\n<p>在Python2.2以后可以使用@classmethod装饰器来创建类方法.</p>\n<pre><code>class Kls(object):\n    no_inst = 0\n    def __init__(self):\n        Kls.no_inst = Kls.no_inst + 1\n    @classmethod\n    def get_no_of_instance(cls_obj):\n        return cls_obj.no_inst\nik1 = Kls()\nik2 = Kls()\nprint ik1.get_no_of_instance()\nprint Kls.get_no_of_instance()\n\n输出:\n2\n2\n</code></pre>\n<p>这样的好处是: 不管这个方式是从实例调用还是从类调用，它都用第一个参数把类传递过来.</p>\n<p>@staticmethod\n经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法. 比如更改环境变量或者修改其他类的属性等能用到静态方法. 这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难.\n比如这样:</p>\n<pre><code>IND = \'ON\'\ndef checkind():\n    return (IND == \'ON\')\nclass Kls(object):\n     def __init__(self,data):\n        self.data = data\ndef do_reset(self):\n    if checkind():\n        print(\'Reset done for:\', self.data)\ndef set_db(self):\n    if checkind():\n        self.db = \'new db connection\'\n        print(\'DB connection made for:\',self.data)\nik1 = Kls(12)\nik1.do_reset()\nik1.set_db()\n\n输出:\nReset done for: 12\nDB connection made for: 12\n</code></pre>\n<p>如果使用@staticmethod就能把相关的代码放到对应的位置了.</p>\n<pre><code>IND = \'ON\'\nclass Kls(object):\n    def __init__(self, data):\n        self.data = data\n    @staticmethod\n    def checkind():\n        return (IND == \'ON\')\n    def do_reset(self):\n        if self.checkind():\n            print(\'Reset done for:\', self.data)\n    def set_db(self):\n        if self.checkind():\n            self.db = \'New db connection\'\n        print(\'DB connection made for: \', self.data)\nik1 = Kls(12)\nik1.do_reset()\nik1.set_db()\n\n输出:\nReset done for: 12\nDB connection made for: 12\n</code></pre>\n<p>下面这个更全面的代码和图示来展示这两种方法的不同\n@staticmethod 和 @classmethod的不同</p>\n<pre><code>class Kls(object):\n    def __init__(self, data):\n        self.data = data\n    def printd(self):\n        print(self.data)\n    @staticmethod\n    def smethod(*arg):\n        print(\'Static:\', arg)\n    @classmethod\n    def cmethod(*arg):\n        print(\'Class:\', arg)\n\n&gt;&gt;&gt; ik = Kls(23)\n&gt;&gt;&gt; ik.printd()\n23\n&gt;&gt;&gt; ik.smethod()\nStatic: ()\n&gt;&gt;&gt; ik.cmethod()\nClass: (&lt;class \'__main__.Kls\'&gt;,)\n&gt;&gt;&gt; Kls.printd()\nTypeError: unbound method printd() must be called with Kls instance as first argument (got nothing instead)\n&gt;&gt;&gt; Kls.smethod()\nStatic: ()\n&gt;&gt;&gt; Kls.cmethod()\nClass: (&lt;class \'__main__.Kls\'&gt;,)\n</code></pre>\n<p>@functools.wraps<br>\n<a href=\"https://docs.python.org/3.4/library/functools.html?highlight=functools#functools.partial\" rel=\"nofollow\">https://docs.python.org/3.4/library/functools.html?highlight=functools#functools.partial</a></p>\n<pre><code>from functools import wraps\n\ndef my_decorator(f):\n    @wraps(f)\n    def wrapper(*args, **kwds):\n        print(\'Calling decorated function\')\n        return f(*args, **kwds)\n    return wrapper\n\n@my_decorator\ndef example():\n    \"\"\"Docstring\"\"\"\n    print(\'Called example function\')\n\nexample()\n\nexample.__name__\n\nexample.__doc__\n</code></pre>','Python普通方法，静态方法和类方法 ','@staticmethod , @classmethod,@functools.wraps'),(21,'post_form.validate_on_submit() ，post_form.is_submitted() 会在用户点击任何按钮时都返回True值，改为  \r\npost_form.data[\'submit\']，  post_form.data[\'cancel\']: 来获取特定迎按钮的点击','2016-07-08 08:45:22',1,'<p>post_form.validate_on_submit() ，post_form.is_submitted() 会在用户点击任何按钮时都返回True值，改为<br>\npost_form.data[\'submit\']，  post_form.data[\'cancel\']: 来获取特定迎按钮的点击</p>','flask wtforms','一表单多提交按钮解决方法'),(22,'print() 时，打印为 \\__str\\__ 中定义内容  \r\n交互环境中时，打印为 \\__repr\\__ 中定义内容\r\n\r\n    class Node:\r\n        def __init__(self, value):\r\n            self._value = value\r\n            self._children = []\r\n    \r\n        def __str__(self):  # !r打印时保留引号\r\n            return \'Node({!r})\'.format(self._value)\r\n        \"\"\"    \r\n        def __str__(self):\r\n            return \'Node({!s})\'.format(self._value)\r\n        \"\"\"\r\n        def add_child(self, node):\r\n            self._children.append(node)\r\n    \r\n        def __iter__(self):\r\n            return iter(self._children)\r\n    \r\n    # Example\r\n    if __name__ == \'__main__\':\r\n        root = Node(0)\r\n        child1 = Node(\'m\')\r\n        child2 = Node(\'2\')\r\n        root.add_child(child1)\r\n        root.add_child(child2)\r\n        # Outputs Node(1), Node(2)\r\n        for ch in root:\r\n            print(ch)\r\n    \r\n    \"\"\"\r\n    #print()打印__str__\r\n    >>> class Pair:\r\n        def __init__(self, x, y):\r\n            self.x = x\r\n            self.y = y\r\n        def __repr__(self):\r\n            return \'Pair({0.x!r}, {0.y!r})\'.format(self)\r\n        def __str__(self):\r\n            return \'({0.x!s}, {0.y!s})\'.format(self)\r\n    >>> p = Pair(3, 4)\r\n    >>> p\r\n    Pair(3, 4)\r\n    >>> print(p)\r\n    (3, 4)\r\n    >>> \"repr() shows quotes: {!r}; str() doesn\'t: {!s}\".format(\'test1\', \'test2\')\r\n    \"repr() shows quotes: \'test1\'; str() doesn\'t: test2\"\r\n    \"\"\"','2016-07-13 08:28:43',1,'<p>print() 时，打印为 _<em>str_</em> 中定义内容<br>\n交互环境中时，打印为 _<em>repr_</em> 中定义内容</p>\n<pre><code>class Node:\n    def __init__(self, value):\n        self._value = value\n        self._children = []\n\n    def __str__(self):  # !r打印时保留引号\n        return \'Node({!r})\'.format(self._value)\n    \"\"\"    \n    def __str__(self):\n        return \'Node({!s})\'.format(self._value)\n    \"\"\"\n    def add_child(self, node):\n        self._children.append(node)\n\n    def __iter__(self):\n        return iter(self._children)\n\n# Example\nif __name__ == \'__main__\':\n    root = Node(0)\n    child1 = Node(\'m\')\n    child2 = Node(\'2\')\n    root.add_child(child1)\n    root.add_child(child2)\n    # Outputs Node(1), Node(2)\n    for ch in root:\n        print(ch)\n\n\"\"\"\n#print()打印__str__\n&gt;&gt;&gt; class Pair:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __repr__(self):\n        return \'Pair({0.x!r}, {0.y!r})\'.format(self)\n    def __str__(self):\n        return \'({0.x!s}, {0.y!s})\'.format(self)\n&gt;&gt;&gt; p = Pair(3, 4)\n&gt;&gt;&gt; p\nPair(3, 4)\n&gt;&gt;&gt; print(p)\n(3, 4)\n&gt;&gt;&gt; \"repr() shows quotes: {!r}; str() doesn\'t: {!s}\".format(\'test1\', \'test2\')\n\"repr() shows quotes: \'test1\'; str() doesn\'t: test2\"\n\"\"\"\n</code></pre>','python __str__ , __repr__区别','python __str__ , __repr__区别'),(23,'    #!/usr/bin/env python\r\n    # -*- coding: utf-8 -*-\r\n    \r\n    import codecs\r\n    \r\n    f1 = open(r\'test_ANSI.txt\',\'r\')  #wineows下解析ansi的文件\r\n    content1 = f1.read()\r\n    print(content1)\r\n    f1.close()\r\n    \r\n    \r\n    f2 = codecs.open(r\'test_utf8.txt\', \'w\',encoding=\'utf8\',errors=\'strict\')   #wineows下解析uft8无bom的文件,utf8仍存在问题\r\n    content2 = f2.read()\r\n    print(content2)\r\n    f2.close()\r\n    \r\n    \r\n    \"\"\"\r\n    >>> import sys\r\n    >>> sys.stdout.encoding\r\n    \'cp936\'\r\n    >>> s=\'aaa\'\r\n    >>> type(s)\r\n    <class \'str\'>\r\n    >>> import sys\r\n    >>> s.encode(encoding=\'UTF-8\')\r\n    b\'aaa\'\r\n    >>> s.encode(encoding=\'UTF-8\').decode()\r\n    \'aaa\'\r\n    \"\"\"\r\n    \r\n    \r\n    \"\"\"\r\n    # windows下编码问题修复\r\n    import sys  \r\n      \r\n    class UnicodeStreamFilter:  \r\n        def __init__(self, target):  \r\n            self.target = target  \r\n            self.encoding = \'utf-8\'  \r\n            self.errors = \'replace\'  \r\n            self.encode_to = self.target.encoding  \r\n        def write(self, s):  \r\n            if type(s) == str:\r\n                s = s.decode(\"utf-8\")  \r\n            s = s.encode(self.encode_to, self.errors).decode(self.encode_to)  \r\n            self.target.write(s)  \r\n    print(sys.stdout.encoding)       \r\n    if sys.stdout.encoding == \'cp936\':\r\n        #print(\'type(sys.stdout)\',type(sys.stdout))\r\n        sys.stdout = UnicodeStreamFilter(sys.stdout)\r\n    if __name__ == \"__main__\":\r\n        print(sys.stdout.encoding)\r\n        a = \"你好\"  \r\n        b = u\"你好\"  \r\n        print (a)  \r\n        print (b)  \r\n        \r\n    \"\"\"','2016-07-13 08:53:13',1,'<pre><code>#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport codecs\n\nf1 = open(r\'test_ANSI.txt\',\'r\')  #wineows下解析ansi的文件\ncontent1 = f1.read()\nprint(content1)\nf1.close()\n\n\nf2 = codecs.open(r\'test_utf8.txt\', \'w\',encoding=\'utf8\',errors=\'strict\')   #wineows下解析uft8无bom的文件,utf8仍存在问题\ncontent2 = f2.read()\nprint(content2)\nf2.close()\n\n\n\"\"\"\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.stdout.encoding\n\'cp936\'\n&gt;&gt;&gt; s=\'aaa\'\n&gt;&gt;&gt; type(s)\n&lt;class \'str\'&gt;\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; s.encode(encoding=\'UTF-8\')\nb\'aaa\'\n&gt;&gt;&gt; s.encode(encoding=\'UTF-8\').decode()\n\'aaa\'\n\"\"\"\n\n\n\"\"\"\n# windows下编码问题修复\nimport sys\n\nclass UnicodeStreamFilter:  \n    def __init__(self, target):  \n        self.target = target  \n        self.encoding = \'utf-8\'  \n        self.errors = \'replace\'  \n        self.encode_to = self.target.encoding  \n    def write(self, s):  \n        if type(s) == str:\n            s = s.decode(\"utf-8\")  \n        s = s.encode(self.encode_to, self.errors).decode(self.encode_to)  \n        self.target.write(s)  \nprint(sys.stdout.encoding)       \nif sys.stdout.encoding == \'cp936\':\n    #print(\'type(sys.stdout)\',type(sys.stdout))\n    sys.stdout = UnicodeStreamFilter(sys.stdout)\nif __name__ == \"__main__\":\n    print(sys.stdout.encoding)\n    a = \"你好\"  \n    b = u\"你好\"  \n    print (a)  \n    print (b)\n\n\"\"\"\n</code></pre>','python  win系统下编码问题修复','python  win系统下编码问题修复'),(24,'假如有模型的话，直接Model.query.filter(name!=\'\').all()  \r\n假如没模型，就db.session.execute(sql)','2016-07-26 01:49:35',1,'<p>假如有模型的话，直接Model.query.filter(name!=\'\').all()<br>\n假如没模型，就db.session.execute(sql)</p>',' flask-sqlalchemy  查询不等于记录',' flask-sqlalchemy  怎么查询  name != \'\'  的记录'),(25,'http://docs.pythontab.com/flask/flask0.10/patterns/fileuploads.html#uploading-files\r\n###文件上传的基本概念实际上非常简单， 他基本是这样工作的:\r\n\r\n1. 一个 <form> 标签被标记有 enctype=multipart/form-data ，并且 在里面包含一个 <input type=file> 标签。\r\n>表单数据post默认为application/x-www-form-urlencode，可以为<form>标签加入属性enctype=multipart/form-data，使得post的数据按multipart/form-data编码，这种格式通常用于文件上传，二进制传输，但是普通表单数据也可以使用multipart/form-data。\r\n2.  服务端应用通过请求对象上的 files 字典访问文件。\r\n3.  使用文件的 save() 方法将文件永久地 保存在文件系统上的某处。  ','2016-08-03 09:56:18',1,'<p><a href=\"http://docs.pythontab.com/flask/flask0.10/patterns/fileuploads.html#uploading-files\" rel=\"nofollow\">http://docs.pythontab.com/flask/flask0.10/patterns/fileuploads.html#uploading-files</a></p>\n<h3>文件上传的基本概念实际上非常简单， 他基本是这样工作的:</h3>\n<ol>\n<li>一个  标签被标记有 enctype=multipart/form-data ，并且 在里面包含一个  标签。<blockquote>\n<p>表单数据post默认为application/x-www-form-urlencode，可以为标签加入属性enctype=multipart/form-data，使得post的数据按multipart/form-data编码，这种格式通常用于文件上传，二进制传输，但是普通表单数据也可以使用multipart/form-data。</p>\n</blockquote>\n</li>\n<li>服务端应用通过请求对象上的 files 字典访问文件。</li>\n<li>使用文件的 save() 方法将文件永久地 保存在文件系统上的某处。  </li>\n</ol>','flask 文件上传','http://docs.pythontab.com/flask/flask0.10/patterns/fileuploads.html#uploading-files'),(26,'###插入图片测试\r\n![Aaron Swartz](https://raw.githubusercontent.com/penglee87/lpython/master/2048.ico)','2016-08-04 03:27:46',1,'<h3>插入图片测试</h3>\n<p><img></p>','插入图片','插入图片测试'),(27,'paginate() 方法的返回值是一个 Pagination 类对象，这个类在 Flask-SQLAlchemy 中定义。  \r\n这个对象包含很多属性，用于在模板中生成分页链接，因此将其作为参数传入了模板\r\n\r\n###Flask-SQLAlchemy分页对象的属性\r\nitems 当前页面中的记录  \r\nquery 分页的源查询  \r\npage 当前页数  \r\nprev_num 上一页的页数  \r\nnext_num 下一页的页数  \r\nhas_next 如果有下一页，返回 True  \r\nhas_prev 如果有上一页，返回 True  \r\npages 查询得到的总页数  \r\nper_page 每页显示的记录数量  \r\ntotal 查询返回的记录总数  \r\n\r\n###在Flask-SQLAlchemy对象上可调用的方法\r\nprev() 上一页的分页对象  \r\nnext() 下一页的分页对象  \r\niter_pages() 返回一个在分页导航中显示的页数列表  \r\n>iter_pages(left_edge=2,left_current=2,right_current=5,right_edge=2)\r\n一个迭代器，返回一个在分页导航中显示的页数列表。这个列表的最左边显示 left_edge 页，当前页的左边显示 left_current 页，当前页的右边显示 right_current 页，\r\n最右边显示 right_edge 页。  \r\n例如，在一个 100 页的列表中，当前页为第 50 页，使用默认配置，这个方法会返回以下页数：1、2、 None 、48、49、50、51、52、53、54、55、 None 、99、100。 None 表示页数之间的间隔  \r\n\r\n例：\r\n\r\n    page = request.args.get(\'page\', 1, type=int)\r\n    pagination = Post.query.order_by(Post.timestamp.desc()).paginate(page, per_page=current_app.config[\'FLASKY_POSTS_PER_PAGE\'],error_out=False)  #返回一个 Paginate 对象，它包含指定范围内的结果\r\n    posts = pagination.items  #返回Paginate 对象中对应的子项','2016-08-05 07:39:48',1,'<p>paginate() 方法的返回值是一个 Pagination 类对象，这个类在 Flask-SQLAlchemy 中定义。<br>\n这个对象包含很多属性，用于在模板中生成分页链接，因此将其作为参数传入了模板</p>\n<h3>Flask-SQLAlchemy分页对象的属性</h3>\n<p>items 当前页面中的记录<br>\nquery 分页的源查询<br>\npage 当前页数<br>\nprev_num 上一页的页数<br>\nnext_num 下一页的页数<br>\nhas_next 如果有下一页，返回 True<br>\nhas_prev 如果有上一页，返回 True<br>\npages 查询得到的总页数<br>\nper_page 每页显示的记录数量<br>\ntotal 查询返回的记录总数  </p>\n<h3>在Flask-SQLAlchemy对象上可调用的方法</h3>\n<p>prev() 上一页的分页对象<br>\nnext() 下一页的分页对象<br>\niter_pages() 返回一个在分页导航中显示的页数列表  </p>\n<blockquote>\n<p>iter_pages(left_edge=2,left_current=2,right_current=5,right_edge=2)\n一个迭代器，返回一个在分页导航中显示的页数列表。这个列表的最左边显示 left_edge 页，当前页的左边显示 left_current 页，当前页的右边显示 right_current 页，\n最右边显示 right_edge 页。<br>\n例如，在一个 100 页的列表中，当前页为第 50 页，使用默认配置，这个方法会返回以下页数：1、2、 None 、48、49、50、51、52、53、54、55、 None 、99、100。 None 表示页数之间的间隔  </p>\n</blockquote>\n<p>例：</p>\n<pre><code>page = request.args.get(\'page\', 1, type=int)\npagination = Post.query.order_by(Post.timestamp.desc()).paginate(page, per_page=current_app.config[\'FLASKY_POSTS_PER_PAGE\'],error_out=False)  #返回一个 Paginate 对象，它包含指定范围内的结果\nposts = pagination.items  #返回Paginate 对象中对应的子项\n</code></pre>','flask SQLAlchemy 查询过滤器 paginate()','paginate() 返回一个 Paginate 对象，它包含指定范围内的结果'),(28,'SQLAlchemy 几种查询方式总结\r\n\r\n几种常见sqlalchemy查询：\r\n    #简单查询\r\n    print(session.query(User).all())\r\n    print(session.query(User.name, User.fullname).all())\r\n    print(session.query(User, User.name).all())\r\n    \r\n    #带条件查询\r\n    print(session.query(User).filter_by(name=\'user1\').all())\r\n    print(session.query(User).filter(User.name == \"user\").all())\r\n    print(session.query(User).filter(User.name.like(\"user%\")).all())\r\n    \r\n    #多条件查询\r\n    print(session.query(User).filter(and_(User.name.like(\"user%\"), User.fullname.like(\"first%\"))).all())\r\n    print(session.query(User).filter(or_(User.name.like(\"user%\"), User.password != None)).all())\r\n    \r\n    #sql过滤\r\n    print(session.query(User).filter(\"id>:id\").params(id=1).all())\r\n    \r\n    #关联查询 \r\n    print(session.query(User, Address).filter(User.id == Address.user_id).all())\r\n    print(session.query(User).join(User.addresses).all())\r\n    print(session.query(User).outerjoin(User.addresses).all())\r\n    \r\n    #聚合查询\r\n    print(session.query(User.name, func.count(\'*\').label(\"user_count\")).group_by(User.name).all())\r\n    print(session.query(User.name, func.sum(User.id).label(\"user_id_sum\")).group_by(User.name).all())\r\n    \r\n    #子查询\r\n    stmt = session.query(Address.user_id, func.count(\'*\').label(\"address_count\")).group_by(Address.user_id).subquery()\r\n    print(session.query(User, stmt.c.address_count).outerjoin((stmt, User.id == stmt.c.user_id)).order_by(User.id).all())\r\n    \r\n    #exists\r\n    print(session.query(User).filter(exists().where(Address.user_id == User.id)))\r\n    print(session.query(User).filter(User.addresses.any()))\r\n    \r\n限制返回字段查询\r\n    person = session.query(Person.name, Person.created_at,                     \r\n             Person.updated_at).filter_by(name=\"zhongwei\").order_by(            \r\n             Person.created_at).first()\r\n             \r\n记录总数查询：\r\n    from sqlalchemy import func\r\n    \r\n    # count User records, without\r\n    # using a subquery.\r\n    session.query(func.count(User.id))\r\n    \r\n    # return count of user \"id\" grouped\r\n    # by \"name\"\r\n    session.query(func.count(User.id)).\\\r\n            group_by(User.name)\r\n    \r\n    from sqlalchemy import distinct\r\n    \r\n    # count distinct \"name\" values\r\n    session.query(func.count(distinct(User.name)))','2016-08-05 09:11:32',1,'<p>SQLAlchemy 几种查询方式总结</p>\n<p>几种常见sqlalchemy查询：\n    #简单查询\n    print(session.query(User).all())\n    print(session.query(<a href=\"http://User.name\" rel=\"nofollow\">User.name</a>, User.fullname).all())\n    print(session.query(User, <a href=\"http://User.name\" rel=\"nofollow\">User.name</a>).all())</p>\n<pre><code>#带条件查询\nprint(session.query(User).filter_by(name=\'user1\').all())\nprint(session.query(User).filter(<a href=\"http://User.name\" rel=\"nofollow\">User.name</a> == \"user\").all())\nprint(session.query(User).filter(User.name.like(\"user%\")).all())\n\n#多条件查询\nprint(session.query(User).filter(and_(User.name.like(\"user%\"), User.fullname.like(\"first%\"))).all())\nprint(session.query(User).filter(or_(User.name.like(\"user%\"), User.password != None)).all())\n\n#sql过滤\nprint(session.query(User).filter(\"id&gt;:id\").params(id=1).all())\n\n#关联查询 \nprint(session.query(User, Address).filter(<a href=\"http://User.id\" rel=\"nofollow\">User.id</a> == Address.user_id).all())\nprint(session.query(User).join(User.addresses).all())\nprint(session.query(User).outerjoin(User.addresses).all())\n\n#聚合查询\nprint(session.query(<a href=\"http://User.name\" rel=\"nofollow\">User.name</a>, func.count(\'*\').label(\"user_count\")).group_by(<a href=\"http://User.name\" rel=\"nofollow\">User.name</a>).all())\nprint(session.query(<a href=\"http://User.name\" rel=\"nofollow\">User.name</a>, func.sum(<a href=\"http://User.id\" rel=\"nofollow\">User.id</a>).label(\"user_id_sum\")).group_by(<a href=\"http://User.name\" rel=\"nofollow\">User.name</a>).all())\n\n#子查询\nstmt = session.query(Address.user_id, func.count(\'*\').label(\"address_count\")).group_by(Address.user_id).subquery()\nprint(session.query(User, stmt.c.address_count).outerjoin((stmt, <a href=\"http://User.id\" rel=\"nofollow\">User.id</a> == stmt.c.user_id)).order_by(<a href=\"http://User.id\" rel=\"nofollow\">User.id</a>).all())\n\n#exists\nprint(session.query(User).filter(exists().where(Address.user_id == <a href=\"http://User.id\" rel=\"nofollow\">User.id</a>)))\nprint(session.query(User).filter(User.addresses.any()))\n</code></pre>\n<p>限制返回字段查询\n    person = session.query(<a href=\"http://Person.name\" rel=\"nofollow\">Person.name</a>, Person.created_at,                   <br>\n             Person.updated_at).filter_by(name=\"zhongwei\").order_by(          <br>\n             Person.created_at).first()</p>\n<p>记录总数查询：\n    from sqlalchemy import func</p>\n<pre><code># count User records, without\n# using a subquery.\nsession.query(func.count(<a href=\"http://User.id\" rel=\"nofollow\">User.id</a>))\n\n# return count of user \"id\" grouped\n# by \"name\"\nsession.query(func.count(<a href=\"http://User.id\" rel=\"nofollow\">User.id</a>)).\\\n        group_by(<a href=\"http://User.name\" rel=\"nofollow\">User.name</a>)\n\nfrom sqlalchemy import distinct\n\n# count distinct \"name\" values\nsession.query(func.count(distinct(<a href=\"http://User.name\" rel=\"nofollow\">User.name</a>)))\n</code></pre>','SQLAlchemy 几种查询方式总结','SQLAlchemy 几种查询方式总结');
/*!40000 ALTER TABLE `posts` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `roles`
--

DROP TABLE IF EXISTS `roles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `roles` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(64) DEFAULT NULL,
  `default` tinyint(1) DEFAULT NULL,
  `permissions` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  KEY `ix_roles_default` (`default`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `roles`
--

LOCK TABLES `roles` WRITE;
/*!40000 ALTER TABLE `roles` DISABLE KEYS */;
INSERT INTO `roles` VALUES (1,'Administrator',0,255),(2,'Moderator',0,15),(3,'User',1,7);
/*!40000 ALTER TABLE `roles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(64) DEFAULT NULL,
  `role_id` int(11) DEFAULT NULL,
  `email` varchar(64) DEFAULT NULL,
  `password_hash` varchar(128) DEFAULT NULL,
  `confirmed` tinyint(1) DEFAULT NULL,
  `about_me` text,
  `last_seen` datetime DEFAULT NULL,
  `location` varchar(64) DEFAULT NULL,
  `member_since` datetime DEFAULT NULL,
  `name` varchar(64) DEFAULT NULL,
  `avatar_hash` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `ix_users_username` (`username`),
  UNIQUE KEY `ix_users_email` (`email`),
  KEY `role_id` (`role_id`),
  CONSTRAINT `users_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `roles` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES (1,'penglee87',1,'penglee87@163.com','pbkdf2:sha1:1000$GJm974fY$a2e34fa352e714c23de824ecdaeeff9fd0cb1774',1,NULL,'2016-09-28 09:49:04',NULL,'2016-06-09 09:57:05',NULL,NULL),(2,'lipeng',3,'lipeng@163.com','pbkdf2:sha1:1000$AQW11a5B$ad3a19c9fd1035fafc12965637bc36ebbe8f04ed',1,NULL,'2016-07-08 10:11:39',NULL,'2016-07-01 02:44:04',NULL,NULL),(3,'Connie',3,'306604496@qq.com','pbkdf2:sha1:1000$UgXyBnrb$0e92d8bd51648bfe3c29156de6aa5e91a894f0ef',0,NULL,'2016-07-08 09:05:09',NULL,'2016-07-08 09:05:09',NULL,NULL),(4,'ads',3,'123@qq.com','pbkdf2:sha1:1000$cPwUBR3h$c5824b72895f8704be48bdd3aabddd7396da9414',0,NULL,'2016-08-10 09:56:06',NULL,'2016-08-10 09:55:00',NULL,NULL);
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2016-09-28 17:50:19
